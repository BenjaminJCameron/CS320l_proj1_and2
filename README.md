# CS320l_proj1_and2
To make sure my code and software are functional and secure, I’ve learned that testing plays a huge role. In Project One, I didn’t fully cover all the requirements at first, and that showed in my test results. After getting feedback, I went back and made sure every validation—like checking for null values, length limits, and future dates—was tested properly. Using JUnit and the Arrange-Act-Assert pattern helped keep my tests organized and focused. I also learned that it’s important to think about edge cases and how users might break the system, which made the program more stable and secure overall. Project Two gave me the chance to reflect on this process and really understand how techniques like unit testing and integration testing can help catch issues before they become real problems.

When it comes to understanding user needs, these projects taught me to pay close attention to the requirements. For example, I had to make sure the contact ID was no longer than 10 characters, or that appointment dates weren’t set in the past. These might seem like small things, but they really matter to the user. I found that treating the rubric like a set of user expectations helped me build the right features. In my reflection for Project Two, I realized how important it is to write tests that reflect how the program will be used in the real world, not just in theory.

As for designing software, I’ve started to approach it more thoughtfully. In Project One, I broke the work down into separate modules—Contact, Task, and Appointment—and made sure each class handled its own responsibilities. I built validation into the classes from the start and used testing to help guide the design. Planning ahead, writing clean code, and staying disciplined really made a difference. These projects helped me understand that good design isn’t just about writing code that works—it’s about writing code that’s easy to test, maintain, and improve later on.
